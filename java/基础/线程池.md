# 线程池参数

|参数名	|作用
| --------   | -----:  |
|corePoolSize	|核心线程池大小
|maximumPoolSize|	最大线程池大小
|keepAliveTime	| 线程池中超过corePoolSize数目的空闲线程最大存活时间；当设置allowCoreThreadTimeOut=true会使得核心线程也超时被释放
|TimeUnit	|keepAliveTime时间单位
|workQueue	|阻塞任务队列
|threadFactory	|新建线程工厂
|RejectedExecutionHandler	|当提交任务数超过maxmumPoolSize + workQueue之和时，任务会交给RejectedExecutionHandler来处理

# 如何设置参数
## 默认值

```java
corePoolSize=1
queueCapacity=Integer.MAX_VALUE
maxPoolSize=Integer.MAX_VALUE
keepAliveTime=60s
allowCoreThreadTimeout=false
rejectedExecutionHandler=AbortPolicy()
```
## 参考值

```java
QPS ：每秒的任务数，假设为500~1000
cost_time ：每个任务花费时间，假设为0.1s
max_response_time ：系统允许容忍的最大响应时间，假设为1s
```

## 得出数据
```java
corePoolSize = 每秒需要多少个线程处理？
threadcount = QPS / ( 1s/cost_time ) = QPS * cost_time =  (500~1000)*0.1 = 50~100 个线程。corePoolSize设置应该大于50
根据8020原则，如果80%的每秒任务数小于800，那么corePoolSize设置为80即可

queueCapacity = (corePoolSize / cost_time) * max_response_time
计算可得 queueCapacity = 80/0.1 * 1 = 80。意思是队列里的线程可以等待1s，超过了的需要新开线程来执行
切记不能设置为Integer.MAX_VALUE，这样队列会很大，线程数只会保持在corePoolSize大小，当任务陡增时，不能新开线程来执行，响应时间会随之陡增。

最大线程数 = （最大任务数-队列容量）/每个线程每秒处理能力
maxPoolSize = (max(QPS)- queueCapacity) / (1s/cost_time)
计算可得 maxPoolSize = (1000-80)/10 = 92

rejectedExecutionHandler：根据具体情况来决定，任务不重要可丢弃，任务重要则要利用一些缓冲机制来处理
keepAliveTime和allowCoreThreadTimeout采用默认通常能满足
```

# 参考

https://blog.csdn.net/java1993666/article/details/71272559
