## H建立连接

![image-20201011205630114](/Users/jinhua.zhang/Library/Application Support/typora-user-images/image-20201011205630114.png)

> - 第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认
> - 第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态
> - Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了

## 数据传输

http://c.biancheng.net/view/2349.html

连接建立后，开始发送数据。操作系统为每个socket连接分配两块内存区域：发送缓冲区、接收缓冲区。

![image-20201011211417592](/Users/jinhua.zhang/Library/Application Support/typora-user-images/image-20201011211417592.png)

调用recv/read方法实际是从缓冲区中获取数据。send/write也是将数据发送到缓冲区中。

输入输出缓冲区的默认大小一般都是 8K。可以通过 getsockopt() 函数获取。也可通过调整TCP参数进行设置。

### 五种网络编程模型

https://blog.51cto.com/10704527/1782715

#### 阻塞IO

默认情况下，都是阻塞IO。调用read后，如果缓冲区没有数据，那么read函数会阻塞，直到缓冲区有数据

![image-20201011215409534](/Users/jinhua.zhang/Library/Application Support/typora-user-images/image-20201011215409534.png)

#### 非阻塞IO

非阻塞IO在用户调用read/write后，如果没有数据/不可写，会立即返回一个error。

因为不会阻塞住线程，因此可以采用连接池方式，处理大量请求。不断轮询socket，调用read，直到数据准备好。这种方式会产生大量无效轮询。

![image-20201011215428789](/Users/jinhua.zhang/Library/Application Support/typora-user-images/image-20201011215428789.png)

#### IO复用模型

I/O 复用模型会用到select、poll、epoll函数，这几个函数也会使进程阻塞，但是和阻塞I/O所不同的，这几个函数可以同时阻塞多个I/O操 作。而且可以同时对多个读操作，多个写操作的I/O函数进行检测，直到有数据可读或可写时，才真正调用I/O操作函数。（比阻塞式I/O并没有上面优越性，但它实现了对多个I/O端口的监听）

![image-20201011215536342](/Users/jinhua.zhang/Library/Application Support/typora-user-images/image-20201011215536342.png)

#### **信号驱动I/O模型**

首先要允许接口进行信号驱动I/O，然后安装一个信号处理函数，线程继续运行并不阻塞。当数据准备好时，线程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据

![image-20201011215452920](/Users/jinhua.zhang/Library/Application Support/typora-user-images/image-20201011215452920.png)

#### **异步IO模型**

当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者的输入输出操作

![image-20201011215558079](/Users/jinhua.zhang/Library/Application Support/typora-user-images/image-20201011215558079.png)



### TCP粘包问题

数据的接收和发送是无关的，read()/recv() 函数不管数据发送了多少次，都会尽可能多的接收数据。也就是说，read()/recv() 和 write()/send() 的执行次数可能不同。

例如，write()/send() 重复执行三次，每次都发送字符串"abc"，那么目标机器上的 read()/recv() 可能分三次接收，每次都接收"abc"；也可能分两次接收，第一次接收"abcab"，第二次接收"cabc"；也可能一次就接收到字符串"abcabcabc"。

针对粘包问题，一般有以下几种解决方案，netty也提供了相应的实现

> - FixedLengthFrameDecoder(固定长度的拆包器): 固定长度的拆包器
> - LineBasedFrameDecoder(行拆包器):每个应用层数据包，都以换行符作为分隔符，进行分割拆分
> - DelimiterBasedFrameDecoder(分隔符拆包器):每个应用层数据包，都通过自定义的分隔符，进行分割拆分
> - LengthFieldBasedFrameDecoder(基于数据包长度的拆包器):将应用层数据包的长度，作为接收端应用层数据包的拆分依据。按照应用层数据包的大小拆包

### 可靠传输

https://www.jianshu.com/p/6aac4b2a9fd7

![image-20201011220111496](/Users/jinhua.zhang/Library/Application Support/typora-user-images/image-20201011220111496.png)

> TCP通过序列号、检验和、确认应答信号、重发控制、连接管理、窗口控制、流量控制、拥塞控制、超时重传、停止等待协议实现可靠性

#### 序号

TCP 给发送的每一个包进行编号，接收方按照序号对数据包进行排序，把有序数据传送给应用层

#### 检验和

TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段

TCP 的接收端会丢弃重复的数据

#### 确认应答信号

#### 窗口控制

#### 流量控制

TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）

TCP 中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0 时，发送方一般不能再发送数据报，但有两种情况除外，一种情况是可以发送紧急数据，例如，允许用户终止在远端机上的运行进程。另一种情况是发送方可以发送一个 1 字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小

#### 拥塞控制

当网络拥塞时，减少数据的发送。

在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。

为了进行拥塞控制，TCP 发送方要维持一个 拥塞窗口(cwnd) 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。

TCP的拥塞控制采用了四种算法，即 **慢开始 、 拥塞避免 、快重传 和 快恢复**。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。

- **慢开始**： 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。

  ![image-20201011220930224](/Users/jinhua.zhang/Library/Application Support/typora-user-images/image-20201011220930224.png)

- 拥塞避免： 拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的cwnd加1

- 快重传与快恢复
   在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作

![image-20201011221050973](/Users/jinhua.zhang/Library/Application Support/typora-user-images/image-20201011221050973.png)

#### 超时重传

当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。

####  停止等待协议

每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组；
在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认

## 断开连接

![image-20201011222805819](/Users/jinhua.zhang/Library/Application Support/typora-user-images/image-20201011222805819.png)